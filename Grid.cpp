
// ----------------------------------------------------------------------------
//
//  Grid class
//    Implementation
//
//  Autogenerated by Class Wizard, by Stephen Wetzel, on April 19, 2014
//
//
// ----------------------------------------------------------------------------
//  Author:        Stephen Wetzel
//  Date:          
//
// ----------------------------------------------------------------------------

#include "Grid.h" //
#include <iostream> //Basic input output (cout)
#include <string> //strings
#include <sstream> //used to convert streams to strings
#include <ostream> //output streams
#include <vector> //vectors
using namespace std;

//--- global constants used for the Grid class

// ------------------------------------------------------
// ----- Constructors -----------------------------------
// ------------------------------------------------------

Grid::Grid()
{//Default constructor
  rows_    = 5; //default to size 5 grid
  columns_ = 5;
	grid_.resize(columns_+1, vector<int>(rows_+1, 1)); //create grid of 1's
}

Grid::Grid(
    int  rows,
    int  columns)
{//Alternate Constructor:
  rows_    = rows;
  columns_ = columns;
  
  //we are not using row and column 0
  grid_.resize(columns+1, vector<int>(rows+1, 1)); //create grid of 1's
}

Grid::Grid(const Grid &obj)
{//copy constructor
  //grid_    = obj.grid_;
  rows_    = obj.rows_;
  columns_ = obj.columns_;
}

Grid::~Grid()
{//destructor
  grid_.clear();
}

// ------------------------------------------------------
// ----- Inspectors -------------------------------------
// ------------------------------------------------------

int Grid::getRows() const
{
  return rows_;
}
int Grid::getColumns() const
{
  return columns_;
}

bool Grid::areMoreMoves() const
{//check to see if there are legal moves left
	for (int ii = 1; ii <= rows_; ii++)
  {//go through the rows
		for (int jj = 1; jj <= columns_; jj++)
		{//go through the columns
			//now check each of the 8 positions around this square
			//starting with upper left and working clockwise
			//if we find any legal move then just return true
			if (isLegalMove(ii-1, jj-1, ii+1, jj+1)) return true; //start upper left
			if (isLegalMove(ii-1, jj  , ii+1, jj  )) return true; //start above
			if (isLegalMove(ii-1, jj+1, ii+1, jj-1)) return true; //start upper right
			if (isLegalMove(ii  , jj+1, ii  , jj-1)) return true; //start right
			if (isLegalMove(ii+1, jj+1, ii-1, jj-1)) return true; //start lower right
			if (isLegalMove(ii+1, jj  , ii-1, jj  )) return true; //start below
			if (isLegalMove(ii+1, jj-1, ii-1, jj+1)) return true; //start lower left
			if (isLegalMove(ii  , jj-1, ii  , jj+1)) return true; //start left
		}
	}
	//never found a legal move after going through each square
	return false;
}

bool Grid::isGameWon() const
{//check to see if the game is won, which means there is exactly 1 peg left
	int pegCount = 0;
	for (int ii = 1; ii <= rows_; ii++)
  {//go through the rows
		for (int jj = 1; jj <= columns_; jj++)
		{//go through the columns
			if (grid_[ii][jj]) pegCount++; //count the pegs
		}
	}
	if (pegCount == 1) return true; //game is only won if there is exactly 1 peg left
	return false;
}


bool Grid::isLegalMove(int startPosRow, int startPosColumn, int endPosRow, int endPosColumn) const
{//check to see if move given is legal
	//return false if any condition isn't met
	
	//startPos and endPos are legal positions on the board; 
	if (startPosRow < 1 || startPosRow > rows_) return false;
	if (startPosColumn < 1 || startPosColumn > columns_) return false;
	if (endPosRow < 1 || endPosRow > rows_) return false;
	if (endPosColumn < 1 || endPosColumn > columns_) return false;
	
	//find middle position and distance between start and end:
	int middlePosRow = (startPosRow + endPosRow) / 2;
	int middlePosColumn = (startPosColumn + endPosColumn) / 2;
	int rowDistance = abs(startPosRow - endPosRow);
	int columnDistance = abs(startPosColumn - endPosColumn);
	
	//startPos and endPos are the correct distance apart;
	if (startPosRow == endPosRow && startPosColumn == endPosColumn) return false;
	if (rowDistance == 1 || rowDistance > 2) return false;
	if (columnDistance == 1 || columnDistance > 2) return false;
	
	//there is a peg in startPos=(startPosRow,startColumn)
	if (!grid_[startPosRow][startPosColumn]) return false;
	
	//there is a peg in the calculated middle position, and
	if (!grid_[middlePosRow][middlePosColumn]) return false;
	
	//there is no peg in endPos=(endPosRow,endPosColumn)
	if (grid_[endPosRow][endPosColumn]) return false;
	
	//all conditions met, so it is a legal move
	return true;
}

// ------------------------------------------------------
// ----- Mutators ---------------------------------------
// ------------------------------------------------------

void Grid::setRows(const int &rows)
{
  rows_ = rows;
}
void Grid::setColumns(const int &columns)
{
  columns_ = columns;
}

void Grid::applyMove(int startPosRow, int startPosColumn, int endPosRow, int endPosColumn) 
{//take in a start and end position, and then makes the move
	//removes peg from start and middle, then adds peg to end
	
	//first confirm this is a legal move:
	if (!isLegalMove(startPosRow, startPosColumn, endPosRow, endPosColumn)) return;
	
	//find middle position from start and end point
	int middlePosRow = (startPosRow + endPosRow) / 2;
	int middlePosColumn = (startPosColumn + endPosColumn) / 2;
	
	grid_[startPosRow][startPosColumn] = 0;
	grid_[middlePosRow][middlePosColumn] = 0;
	grid_[endPosRow][endPosColumn] = 1;
}

void Grid::removePeg(int row, int column)
{//remove one peg from a specific position
	grid_[row][column] = 0;
}



// ------------------------------------------------------
// ----- Facilitators -----------------------------------
// ------------------------------------------------------

string Grid::display() const
{//output the grid with formatting
	char pegSymbol[2] = {' ', 'X'}; //symbols for no peg, and peg respectively
	char gridLetters[] = " ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	
  ostringstream os; 
  
  os << "\n   ";
  for (int jj = 1; jj <= columns_; jj++)
  {//the column numbers along the top
		os << " "<<jj;
	}
	os << "\n  +";
  for (int jj = 1; jj <= columns_; jj++)
  {//top spacing bar
		os << "--";
	}
	os<< "-+";
	
  for (int ii = 1; ii <= rows_; ii++)
  {//go through each row
		os <<"\n"<<gridLetters[ii]<<" |"; //start the line and add the left border
		for (int jj = 1; jj <= columns_; jj++)
		{//go through each column in a row and print peg
			os << " " << pegSymbol[grid_[ii][jj]];
		}
		os <<" |"; //right border
	}
	
	os << "\n  +";
  for (int jj = 1; jj <= columns_; jj++)
  {//bottom spacing bar
		os << "--";
	}
	os<< "-+";
	os << "\n";
  return os.str();
}



// ------------------------------------------------------
// ----- Overloaded Operators----------------------------
// ------------------------------------------------------

ostream &operator<< (ostream &out, const Grid &obj)
{
  out<<obj.display(); 
  return out;
}

vector<int> & Grid::operator[] (int ii)
{
	//returns a 1d vector, which then has a regular [] operator that can be used on it
  return grid_[ii];
}


